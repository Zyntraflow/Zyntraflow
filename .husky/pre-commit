set -eu

fail() {
  echo "ERROR: $1" >&2
  exit 1
}

if git ls-files --error-unmatch .env >/dev/null 2>&1; then
  fail ".env is tracked by git. Run: git rm --cached .env"
fi

if git diff --cached --name-only | grep -Eq '^\.env$'; then
  fail ".env is staged. Run: git rm --cached .env"
fi

if git ls-files --error-unmatch .env.operator >/dev/null 2>&1; then
  fail ".env.operator is tracked by git. Run: git rm --cached .env.operator"
fi

if git diff --cached --name-only | grep -Eq '^\.env\.operator$'; then
  fail ".env.operator is staged. Remove it from staging."
fi

extract_nonempty_assignment_line() {
  file="$1"
  key_pattern="$2"

  git show ":$file" | awk -v pattern="$key_pattern" '
    $0 ~ "^[[:space:]]*(" pattern ")[[:space:]]*=" {
      value = $0
      sub(/^[[:space:]]*[A-Z0-9_]+[[:space:]]*=[[:space:]]*/, "", value)
      sub(/[[:space:]]+#.*$/, "", value)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", value)
      if (length(value) > 0) {
        print NR
        exit 0
      }
    }
    END { exit 1 }
  ' || true
}

extract_nonempty_alchemy_line() {
  file="$1"

  git show ":$file" | awk '
    $0 ~ "^[[:space:]]*ALCHEMY_URL[[:space:]]*=" {
      value = $0
      sub(/^[[:space:]]*ALCHEMY_URL[[:space:]]*=[[:space:]]*/, "", value)
      sub(/[[:space:]]+#.*$/, "", value)
      gsub(/^[[:space:]]+|[[:space:]]+$/, "", value)
      if (length(value) > 0 && (value ~ /^https?:\/\// || value ~ /\/v2\//)) {
        print NR
        exit 0
      }
    }
    END { exit 1 }
  ' || true
}

staged_files="$(git diff --cached --name-only --diff-filter=ACMR)"
if [ -z "$staged_files" ]; then
  exit 0
fi

old_ifs=$IFS
IFS='
'
for file in $staged_files; do
  if [ -z "$file" ]; then
    continue
  fi

  if ! git show ":$file" | grep -Iq .; then
    continue
  fi

  secret_match="$(git show ":$file" | grep -IEn '(^|[^a-fA-F0-9])(0x)?[a-fA-F0-9]{64}([^a-fA-F0-9]|$)' | head -n 1 || true)"
  if [ -n "$secret_match" ]; then
    fail "Potential private key pattern found in staged file '$file' at line ${secret_match%%:*}. Move secrets to local .env"
  fi

  sensitive_line="$(extract_nonempty_assignment_line "$file" 'DISCORD_BOT_TOKEN|TELEGRAM_BOT_TOKEN|PREMIUM_SIGNER_PRIVATE_KEY|IPFS_AUTH_TOKEN')"
  if [ -n "$sensitive_line" ]; then
    fail "Detected non-empty sensitive assignment in '$file' at line $sensitive_line. Keep real values only in local .env/.env.operator"
  fi

  alchemy_line="$(extract_nonempty_alchemy_line "$file")"
  if [ -n "$alchemy_line" ]; then
    fail "Detected non-empty ALCHEMY_URL-like assignment in '$file' at line $alchemy_line. Keep real RPC URLs only in local .env/.env.operator"
  fi
done
IFS=$old_ifs
